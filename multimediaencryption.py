# -*- coding: utf-8 -*-
"""MultimediaEncryption.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1M07kyaeBJt4Qyq3pjbcH4d6O90uSPGZl

Shuffling of Playing Cards

Staggering the P box for each row of image
"""

import cv2 as cv
from google.colab.patches import cv2_imshow
import numpy as np
from numpy import array
import random

# Read and print image
pic = cv.imread('0.png')
pic = cv.resize(pic,(1024,1024))
h, w, r = pic.shape
decks = w // 52 if w % 52 == 0 else w // 52 + 1
pic = cv.resize(pic, (decks*52,h))
h, w, r = pic.shape
pix_val = array(pic)
originalPixels = pix_val.tolist()
print("Original Image")
cv2_imshow(pix_val)

# Shuffle cards
def cardSelection(n):
  card = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
  shape = ['HEART', 'CLUB', 'SPADE', 'DIAMOND']
  deck = random.randint(0,n-1)
  col = random.choice(card)                     # Number on card == column no
  selected_shape = random.choice(shape)         # Shape of card == row no
  if (selected_shape == 'DIAMOND'):
      row = 0
  elif (selected_shape == 'CLUB'):
      row = 1
  elif (selected_shape == 'SPADE'):
      row = 2
  else:
      row = 3
  return (deck, row, col)

# S-box (randomly  generated)
# Diamond = 0, Club = 1, Spade = 2, Heart = 3

def genSBox(deck_number):
  temp = []
  for i in range(52*deck_number, 52*deck_number + 52):
    temp.append(i)
  SBox = []
  for i in range(4):
    SBox.append([])
    for j in range(13):
      t= random.choice(temp)
      SBox[i].append(t)
      temp.remove(t)
  return SBox

# Create P-box
def genPBox(img_size, SBox):
  pbox = []
  while img_size > 0:
    deck, row, col = cardSelection(decks)
    mapped_val = SBox[deck][row][col]
    if mapped_val in pbox:
      continue
    else:
      pbox.append(mapped_val)
      img_size -= 1
  return pbox

# Encryption
def encryption(rpixel, pBox):   #rpixel is row pixel
  en_img=[]
  for i in range(len(rpixel)):
    en_img.append(0)
  for pos in range(len(pBox)):
    en_img[pBox[pos]] = rpixel[pos]
  return en_img

# Decryption
def decryption(rpixel, pBox):
  dec_img = []
  for i in range(len(rpixel)):
    dec_img.append(0)
  for pos in range(len(pBox)):
    dec_img[pos] = rpixel[pBox[pos]]
  return dec_img

# Reading pixels for encryption
encryptedImagePixels = []
sBox = []
for i in range(decks):
  sBox.append(genSBox(i))
key = []
for i in range(len(pix_val)):
  pBox = genPBox(w,sBox) #param = size of the image
  key.append(pBox)
  temp = pix_val[i].tolist()
  rgba_encrypt = encryption(temp, pBox)
  encrypted_rgba = tuple(rgba_encrypt)
  encryptedImagePixels.append(encrypted_rgba)

#Create and print image from encrypted pixels
encrypt_pix_val = array(encryptedImagePixels)
print("\nEncrypted Image")
# cv.imwrite("encrypted.png", encrypt_pix_val)
cv2_imshow(np.uint8(encrypt_pix_val))

# Reading Pixels for decryption
# encryptedImage = array(cv.imread('encrypted.png'))
encryptedImage = encrypt_pix_val
decryptedImagePixels = []
for i in range(len(encryptedImage)):
  pBox = key[i]
  temp = encryptedImage[i].tolist()
  rgba_decrypt = decryption(temp, pBox)
  decrypted_rgba = tuple(rgba_decrypt)
  decryptedImagePixels.append(decrypted_rgba)

#Create and print image from decrypted pixels
decrypt_pix_val = array(decryptedImagePixels)
print("\nDecrypted Image")
# cv.imwrite("decrypted.png", decrypt_pix_val)
cv2_imshow(np.uint8(decrypt_pix_val))

# # Comparing Original and Decrypted Images
# temp = []
# for i in range(len(originalPixels)):
#   temp.append([])
#   for j in range(len(originalPixels[i])):
#     temp[i].append([])
#     for k in range(len(originalPixels[i][j])):
#       temp[i][j].append(originalPixels[i][j][k] - decryptedImagePixels[i][j][k])
# temp = array(temp)
# print("\nCompare")
# cv2_imshow(np.uint8(temp))

